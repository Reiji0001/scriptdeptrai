-- --------------------------------------------------------------------------------
-- KFC HUB FULL - Merged Combat & Utility Logic into Fluent UI Framework
-- --------------------------------------------------------------------------------

-- Load Fluent UI and Addons
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

-- Services & basic 
local Players = game:GetService("Players") 
local RS = game:GetService("ReplicatedStorage") 
local RunService = game:GetService("RunService") 
local UserInputService = game:GetService("UserInputService") 
local localPlayer = Players.LocalPlayer 

-- try require core (some functions depend on it) 
local core = nil 
pcall(function() 
    core = require(RS:WaitForChild("Core")) 
end) 

-- --------------------------------------------------------------------------------
-- HUB State Variables & Core Logic (Refactored from original script)
-- --------------------------------------------------------------------------------

-- Combat States & Variables
local killAura = false 
local distance = 6 -- Kill Aura Range
local hitboxEnabled = false 
local hitboxSize = 20
local wallComboEnabled = false 
local flyEnabled = false
local autoBlockEnabled = false 
local oldBoxFunc 

-- Kill Aura internal variables (initial setup required for the original logic structure)
local v_u_1, v155, v156, v158, v159, v160, v163, v167, v_u_168, v58 

-- Utility States & Variables
local emoteRunning = false 
local emoteMode = "Selected" -- "Selected" or "Random"
local emoteSelected = "Impostor"
local killEmotes = { 
    "Impostor","Laser Eyes","Mistletoe","Naughty List","Neck Snap","Orthax", 
    "Pollen Overload","Possession","Rudolph's Revenge","Samurai Slash","Santamation", 
    "Sawblade Execution","Scythe Sweep","Shadow Ambush","Shattered","Skull Crush", 
    "Slice And Dice","Soul Harvest","Spectral Strike","Spider Feast","Spirit Break", 
    "Stakeout","Stone Slam","Storm Breaker","Suffocate","Sunken Drag","Supreme Cut", 
    "Sword Frenzy","Titan Fist","Torment","Tornado Execution","Twilight End", 
    "Ultra Slash","Umbra Grab","Unholy Binding","Vampire","Void Implosion", 
    "Wrath Slam","Zeus Strike" 
} 
local autoFarmRunning = false
local farmDistance = 2

-- Find the Block Remote once
local BlockRemote = nil 
pcall(function() 
    BlockRemote = RS:WaitForChild("Remotes"):WaitForChild("Combat"):WaitForChild("Block") 
end) 

-- Setup Hitbox Hook if core exists
pcall(function() 
    if core and core.Get and core.Get("Combat","Hit") then 
        oldBoxFunc = core.Get("Combat","Hit").Box 
    end 
end) 


-- --------------------------------------------------------------------------------
-- Combat Logic Functions 
-- --------------------------------------------------------------------------------

local function setupKillAura() 
    pcall(function() 
        v_u_1 = require(RS:WaitForChild("Core")) 
        v155 = localPlayer:WaitForChild("Data"):WaitForChild("Character") 
        v156 = RS.Characters:FindFirstChild(v155.Value):FindFirstChild("WallCombo") 
        v158 = Vector3.new(7, 5, 7) 
        v159 = CFrame.new(0, 0, 0) 
        v160 = v_u_1.Get("Character", "FullCustomReplication").GetCFrame() 
        v163 = localPlayer.Character 
        v167 = {["Size"] = v158, ["Offset"] = v159, ["CustomValidation"] = function() return true end} 
        v_u_168 = v_u_1.Get("Combat", "Hit").Box(nil, v163, v167) 
        v58 = v156:GetAttribute("Interrupt") 
    end) 
end 

function Run(p_u_7, p8, p_u_9, p10, ...) 
    local v_u_11 = p_u_7 and p_u_7:FindFirstChild("Humanoid") or p_u_7 
    local v_u_12 = p_u_7 and p_u_7:FindFirstChild("HumanoidRootPart") or p_u_7 
    if p_u_7 and (v_u_11 and v_u_12) then 
        local v_u_13 = p_u_7 == Players.LocalPlayer.Character 
        local v_u_17 = p8 
        v_u_1.Get("Combat", "Cancel").Init(v_u_17, p_u_9, p_u_7) 
        v_u_1.Get("Combat", "Cancel").Set(v_u_17, p_u_9, p_u_7, "Timeout") 
        local v_u_36 = { ... } 
        task.spawn(function() 
            v_u_1.Get("Cosmetics", "KillEmote").RunAfter(v_u_17, table.unpack({p_u_7, v_u_11, v_u_12, v_u_13, p_u_9, table.unpack(v_u_36)})) 
        end) 
    end 
end 

local function auraLoop()
    if not v_u_1 then 
        setupKillAura() 
        if not v_u_1 then return warn("⚠️ Module Core chưa được tìm thấy.") end 
    end 

    while killAura do 
        -- Must try to update position based on Fluent variable, although original logic used v160
        local originPos = v160 and v160.Position 
        if originPos then
            local pos = originPos + v160.LookVector * distance 
            for i = 1, 6 do 
                v_u_1.Library("Remote").Send("Ability", v156, 9e9, v58, v_u_168, pos) 
                Run(localPlayer.Character, v156, 9e9, v58, v_u_168, pos) 
            end 
        end
        task.wait(0.01) 
    end 
end

local function toggleKillAura(state) 
    killAura = state
    if state then
        task.spawn(auraLoop)
    end
end 

local function toggleFly(state) 
    flyEnabled = state
    if state then 
        pcall(function() 
            loadstring(game:HttpGet("https://raw.githubusercontent.com/XNEOFF/FlyGuiV3/main/FlyGuiV3.txt"))() 
        end) 
    else
        -- Generally difficult to stop injected scripts, logging a warning instead
        warn("💡 Fly script đã được inject, cần phải dừng thủ công nếu script không có cơ chế tắt.")
    end 
end 

local function setHitbox(state) 
    hitboxEnabled = state
    if core and oldBoxFunc then 
        if state then 
            core.Get("Combat","Hit").Box = function(_, target, data) 
                -- Use the current dynamic hitboxSize
                return oldBoxFunc(nil, target, {Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)}) 
            end 
        else 
            core.Get("Combat","Hit").Box = oldBoxFunc 
        end 
    else
        warn("⚠️ Không tìm thấy module Core để thay đổi Hitbox.")
    end 
end 

local function wallcomboLoop() 
    if not (core and RS:FindFirstChild("Characters") and localPlayer:FindFirstChild("Data") and localPlayer.Data:FindFirstChild("Character")) then 
        return warn("⚠️ Không đủ module để Wall Combo") 
    end 
    local chars = RS:FindFirstChild("Characters")
    local charData = localPlayer.Data.Character.Value
    local wallComboAbility = chars[charData] and chars[charData].WallCombo

    local head = localPlayer.Character and localPlayer.Character:FindFirstChild("Head") 
    if not head or not wallComboAbility then return end 
    
    local res = core.Get("Combat","Hit").Box(nil, localPlayer.Character, {Size = Vector3.new(50,50,50)}) 
    if res then 
        pcall(core.Get("Combat","Ability").Activate, wallComboAbility, res, head.Position + Vector3.new(0,0,2.5)) 
    end 
end 

local function toggleWallCombo(state) 
    wallComboEnabled = state
    if state then 
        RunService:BindToRenderStep("WallCombo", Enum.RenderPriority.Input.Value, wallcomboLoop) 
    else 
        RunService:UnbindFromRenderStep("WallCombo") 
    end 
end 

local function enableBlockOnce() 
    if BlockRemote then 
        pcall(function() 
            BlockRemote:FireServer(true) 
        end) 
    end 
end 

-- Auto Block loop (runs continuously, checked by toggle state) 
task.spawn(function() 
    while task.wait(0.05) do 
        if autoBlockEnabled then 
            local character = localPlayer.Character 
            if character then 
                local success, isBlocking = pcall(function() 
                    return character:GetAttribute("IsBlocking") 
                end) 
                if success and not (isBlocking or isBlocking == nil) then 
                    enableBlockOnce() 
                end 
            end 
        end 
    end 
end) 

local function toggleAutoBlock(state)
    autoBlockEnabled = state
end

local function setDashCooldownValue(v) 
    local success, settings = pcall(function() 
        return RS.Settings.Cooldowns 
    end) 
    if success and settings and settings:FindFirstChild("Dash") then 
        local clamped = math.clamp(math.floor(v), 0, 100) 
        settings.Dash.Value = clamped 
    end 
end 

-- --------------------------------------------------------------------------------
-- Utility Logic Functions 
-- --------------------------------------------------------------------------------

local function getNearestPlayer(maxDist) 
    local nearest, dist = nil, maxDist or math.huge 
    for _, p in pairs(Players:GetPlayers()) do 
        if p ~= localPlayer and p.Character and p.Character:FindFirstChild("HumanoidRootPart") then 
            local humanoid = p.Character:FindFirstChildOfClass("Humanoid") 
            if humanoid and humanoid.Health > 0 then 
                local hrp = p.Character.HumanoidRootPart 
                local myhrp = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart") 
                if myhrp then 
                    local d = (myhrp.Position - hrp.Position).Magnitude 
                    if d < dist then 
                        dist = d 
                        nearest = p 
                    end 
                end 
            end 
        end 
    end 
    return nearest 
end 

local function tpToTarget(target, dist) 
    if target and target.Character and target.Character:FindFirstChild("HumanoidRootPart") then 
        local myChar = localPlayer.Character 
        local myHRP = myChar and myChar:FindFirstChild("HumanoidRootPart") 
        local targetHRP = target.Character.HumanoidRootPart 
        if myHRP then 
            local dir = (targetHRP.Position - myHRP.Position).Unit 
            myHRP.CFrame = CFrame.new(targetHRP.Position - dir * dist, targetHRP.Position) 
        end 
    end 
end 

local function farmLoop() 
    if not autoFarmRunning or not core then return end

    local currentTarget = getNearestPlayer(1000)

    if currentTarget and currentTarget.Character then 
        -- Teleport (Always enabled in the original Auto Farm logic)
        tpToTarget(currentTarget, farmDistance) 
        
        -- Attack (using WallCombo ability logic)
        local head = localPlayer.Character and localPlayer.Character:FindFirstChild("Head") 
        if head then 
            local res = nil 
            pcall(function() 
                res = core.Get("Combat","Hit").Box(nil, localPlayer.Character, {Size = Vector3.new(50,50,50)}) 
            end) 
            if res then 
                local chars = RS:WaitForChild("Characters") 
                local charData = localPlayer.Data.Character.Value 
                local ability = chars[charData] and chars[charData].WallCombo 
                if ability then 
                    pcall(core.Get("Combat","Ability").Activate, ability, res, head.Position + Vector3.new(0,0,2.5)) 
                end 
            end 
        end 
    end 
end 

local function toggleAutoFarm(state) 
    autoFarmRunning = state
    if state then 
        RunService:BindToRenderStep("AutoFarm", Enum.RenderPriority.Input.Value, farmLoop) 
    else 
        RunService:UnbindFromRenderStep("AutoFarm") 
    end 
end 

local function getRoot(char) return char and char:FindFirstChild("HumanoidRootPart") end 
local function useEmote(name) 
    local emoteModule = RS:WaitForChild("Cosmetics"):WaitForChild("KillEmote"):FindFirstChild(name) 
    local myRoot = getRoot(localPlayer.Character) 
    if not myRoot or not emoteModule then return end 
    local target = nil 
    local dist = math.huge 
    for _,p in ipairs(Players:GetPlayers()) do 
        if p ~= localPlayer and p.Character and getRoot(p.Character) then 
            local d = (myRoot.Position - getRoot(p.Character).Position).Magnitude 
            if d < dist then dist = d; target = p.Character end 
        end 
    end 
    if target then 
        pcall(function() 
            core.Get("Combat","Ability").Activate(emoteModule,target) 
        end) 
    end 
end 

RunService.RenderStepped:Connect(function() 
    if emoteRunning and core then 
        if emoteMode == "Selected" and emoteSelected then 
            useEmote(emoteSelected) 
        elseif emoteMode == "Random" then 
            useEmote(killEmotes[math.random(1,#killEmotes)]) 
        end 
    end 
end) 

local function toggleEmoteSpam(state)
    emoteRunning = state
end

-- --------------------------------------------------------------------------------
-- Fluent UI Setup
-- --------------------------------------------------------------------------------

local Window = Fluent:CreateWindow({
    Title = "KFC HUB",
    SubTitle = "V8 AURA FIXED | by KZ",
    TabWidth = 160,
    Size = UDim2.fromOffset(500, 460),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl 
})

-- Redefine Tabs
local Tabs = {
    Combat = Window:AddTab({ Title = "Combat", Icon = "swords" }),
    Utility = Window:AddTab({ Title = "Utility", Icon = "tool" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options

-- --------------------------------------------------------------------------------
-- COMBAT TAB
-- --------------------------------------------------------------------------------

do -- Combat Tab Logic

    -- KILL AURA 
    Tabs.Combat:AddToggle("KillAura", {
        Title = "Kill Aura (Aura Fixed)",
        Description = "Tự động tấn công người chơi gần nhất.",
        Default = false,
        Callback = toggleKillAura
    })
    
    Tabs.Combat:AddSlider("KillAuraRange", {
        Title = "Kill Aura Range",
        Description = "Phạm vi tấn công (Blockmate distance).",
        Default = distance,
        Min = 5,
        Max = 100,
        Rounding = 1,
        Callback = function(Value)
            distance = Value
        end
    })

    -- HITBOX
    Tabs.Combat:AddToggle("Hitbox", {
        Title = "Hitbox Extender",
        Description = "Tăng kích thước Hitbox của đòn tấn công.",
        Default = false,
        Callback = setHitbox
    })
    
    local hitboxSlider = Tabs.Combat:AddSlider("HitboxSize", {
        Title = "Hitbox Size",
        Description = "Kích thước mới (mặc định game là ~7-10).",
        Default = hitboxSize,
        Min = 10,
        Max = 50,
        Rounding = 1,
        Callback = function(Value)
            hitboxSize = Value
            if hitboxEnabled then
                setHitbox(true) -- Apply change immediately if enabled
            end
        end
    })

    -- WALL COMBO & FLY
    Tabs.Combat:AddToggle("WallCombo", {
        Title = "Wall Combo Spam",
        Description = "Liên tục kích hoạt kỹ năng WallCombo.",
        Default = false,
        Callback = toggleWallCombo
    })
    
    Tabs.Combat:AddToggle("Fly", {
        Title = "Fly Script Inject",
        Description = "Inject script bay (cần tải từ GitHub).",
        Default = false,
        Callback = toggleFly
    })
    
    -- AUTO BLOCK
    Tabs.Combat:AddToggle("AutoBlock", {
        Title = "Auto Block",
        Description = "Tự động kích hoạt đỡ đòn khi không blocking.",
        Default = false,
        Callback = toggleAutoBlock
    })

    -- DASH COOLDOWN
    Tabs.Combat:AddInput("DashCooldown", {
        Title = "Dash Cooldown (0 = No CD)",
        Default = "1",
        Placeholder = "Giá trị 0-100",
        Numeric = true,
        Finished = true, 
        Callback = function(Value)
            local n = tonumber(Value)
            if n then
                setDashCooldownValue(n)
            end
        end
    })

end

-- --------------------------------------------------------------------------------
-- UTILITY TAB
-- --------------------------------------------------------------------------------

do -- Utility Tab Logic

    -- AUTO FARM
    Tabs.Utility:AddParagraph({
        Title = "Auto Farm",
        Content = "Tự động Teleport đến người chơi gần nhất và spam WallCombo."
    })

    Tabs.Utility:AddToggle("AutoFarmToggle", {
        Title = "Auto Farm Active",
        Description = "Bật/Tắt chế độ Auto Farm.",
        Default = false,
        Callback = toggleAutoFarm
    })

    Tabs.Utility:AddInput("FarmDistance", {
        Title = "Farm Distance",
        Description = "Khoảng cách Teleport đến mục tiêu.",
        Default = tostring(farmDistance),
        Placeholder = "Khoảng cách (mặc định 2)",
        Numeric = true,
        Finished = true,
        Callback = function(Value)
            local n = tonumber(Value)
            if n then
                farmDistance = n
            end
        end
    })

    -- EMOTE SPAM
    Tabs.Utility:AddParagraph({
        Title = "Emote Spam",
        Content = "Liên tục sử dụng Emote kết liễu (KillEmote) vào mục tiêu gần nhất."
    })

    Tabs.Utility:AddToggle("EmoteSpamToggle", {
        Title = "Emote Spam Active",
        Description = "Bật/Tắt chế độ Emote Spam.",
        Default = false,
        Callback = toggleEmoteSpam
    })

    Tabs.Utility:AddDropdown("EmoteMode", {
        Title = "Emote Mode",
        Description = "Chọn chế độ spam: Ngẫu nhiên hoặc Chọn trước.",
        Values = {"Selected", "Random"},
        Multi = false,
        Default = "Selected",
        Callback = function(Value)
            emoteMode = Value
        end
    })

    Tabs.Utility:AddDropdown("SelectedEmote", {
        Title = "Select Emote",
        Description = "Chọn Emote cụ thể để spam.",
        Values = killEmotes,
        Multi = false,
        Default = killEmotes[1],
        Callback = function(Value)
            emoteSelected = Value
        end
    })

end

-- --------------------------------------------------------------------------------
-- ADDONS & FINALIZATION
-- --------------------------------------------------------------------------------

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
SaveManager:IgnoreThemeSettings()

-- Setup folders for configs
InterfaceManager:SetFolder("KFC_HUB_Fluent_Profiles")
SaveManager:SetFolder("KFC_HUB_Fluent_Profiles/GameSettings")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

-- Load last configuration
SaveManager:LoadAutoloadConfig()

Window:SelectTab(1)

Fluent:Notify({
    Title = "KFC HUB Loaded",
    Content = "Đã tải thành công phiên bản Fluent UI.",
    SubContent = "Tất cả cài đặt sẽ được lưu tự động.",
    Duration = 8
})
